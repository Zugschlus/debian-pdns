#! /bin/sh /usr/share/dpatch/dpatch-run
## addfeatures-ldapbackend.dpatch by  <matthijs@monster.cacholong.nl>
##
## All lines beginning with `## DP:' are a description of the patch.
## DP: add query logging
## DP: support for AXFR in non-hierarchical trees
## DP: reenabled AXFR for normal zones in strict mode
## DP: fix for wildcard lookups in tree mode
## DP: fix for thrown exception if multiple assocatedDomain are available
## DP: changed wrong default method
## DP: fix in PowerLDAP if dn is necessary

@DPATCH@
diff -urNad trunk/modules/ldapbackend/ldapbackend.cc /tmp/dpep.52OPft/trunk/modules/ldapbackend/ldapbackend.cc
--- trunk/modules/ldapbackend/ldapbackend.cc	2005-04-09 23:02:03.544791408 +0200
+++ /tmp/dpep.52OPft/trunk/modules/ldapbackend/ldapbackend.cc	2005-04-10 17:43:04.481894376 +0200
@@ -19,6 +19,7 @@
 		m_msgid = 0;
 		m_qname = "";
 		m_pldap = NULL;
+		m_qlog = arg().mustDo( "query-logging" );
 		m_default_ttl = arg().asNum( "default-ttl" );
 		m_myname = "[LdapBackend]";
 
@@ -37,6 +38,7 @@
 
 		if( getArg( "method" ) == "strict" || mustDo( "disable-ptrrecord" ) )
 		{
+			m_list_fcnt = &LdapBackend::list_strict;
 			m_lookup_fcnt = &LdapBackend::lookup_strict;
 			m_prepare_fcnt = &LdapBackend::prepare_strict;
 		}
@@ -121,16 +123,46 @@
 
 inline bool LdapBackend::list_simple( const string& target, int domain_id )
 {
+	string dn;
 	string filter;
 
-	filter = "(|(associatedDomain=" + target + ")(associatedDomain=*." + target + "))";
-	m_msgid = m_pldap->search( getArg("basedn"), LDAP_SCOPE_SUBTREE, filter, (const char**) ldap_attrany );
+
+	// search for SOARecord of target
+	dn = getArg( "basedn" );
+	filter = "(associatedDomain=" + target + ")";
+	m_msgid = m_pldap->search( dn, LDAP_SCOPE_SUBTREE, filter, (const char**) ldap_attrany );
+	m_pldap->getSearchEntry( m_msgid, m_result, true );
+
+	if( m_result.count( "dn" ) && !m_result["dn"].empty() )
+	{
+		dn = m_result["dn"][0];
+		m_result.erase( "dn" );
+	}
+
+	prepare();
+	filter = "(associatedDomain=*." + target + ")";
+	DLOG( L << Logger::Debug << m_myname << " Search = basedn: " << dn << ", filter: " << filter << endl );
+	m_msgid = m_pldap->search( dn, LDAP_SCOPE_SUBTREE, filter, (const char**) ldap_attrany );
 
 	return true;
 }
 
 
 
+inline bool LdapBackend::list_strict( const string& target, int domain_id )
+{
+	if( target.size() > 13 && target.substr( target.size() - 13, 13 ) == ".in-addr.arpa" ||
+		target.size() > 9 && target.substr( target.size() - 9, 9 ) == ".ip6.arpa" )
+	{
+		L << Logger::Warning << m_myname << " Request for reverse zone AXFR, but this is not supported in strict mode" << endl;
+		return false;   // AXFR isn't supported in strict mode. Use simple mode and additional PTR records
+	}
+
+	return list_simple( target, domain_id );
+}
+
+
+
 void LdapBackend::lookup( const QType &qtype, const string &qname, DNSPacket *dnspkt, int zoneid )
 {
 	try
@@ -140,6 +172,7 @@
 		m_qname = qname;
 		m_adomain = m_adomains.end();   // skip loops in get() first time
 
+		if( m_qlog ) { L.log( "Query: '" + qname + "|" + qtype.getName() + "'", Logger::Error ); }
 		(this->*m_lookup_fcnt)( qtype, qname, dnspkt, zoneid );
 	}
 	catch( LDAPTimeout &lt )
@@ -180,7 +213,7 @@
 	}
 
 	DLOG( L << Logger::Debug << m_myname << " Search = basedn: " << getArg( "basedn" ) << ", filter: " << filter << ", qtype: " << qtype.getName() << endl );
-	m_msgid = m_pldap->search( getArg("basedn"), LDAP_SCOPE_SUBTREE, filter, (const char**) attributes );
+	m_msgid = m_pldap->search( getArg( "basedn" ), LDAP_SCOPE_SUBTREE, filter, (const char**) attributes );
 }
 
 
@@ -223,7 +256,7 @@
 	}
 
 	DLOG( L << Logger::Debug << m_myname << " Search = basedn: " << getArg( "basedn" ) << ", filter: " << filter << ", qtype: " << qtype.getName() << endl );
-	m_msgid = m_pldap->search( getArg("basedn"), LDAP_SCOPE_SUBTREE, filter, (const char**) attributes );
+	m_msgid = m_pldap->search( getArg( "basedn" ), LDAP_SCOPE_SUBTREE, filter, (const char**) attributes );
 }
 
 
@@ -237,7 +270,7 @@
 	vector<string> parts;
 
 
-	qesc = toLower( m_pldap->escape( qname ) );
+	qesc = toLower( qname );
 	filter = "(associatedDomain=" + qesc + ")";
 
 	if( qtype.getCode() != QType::ANY )
@@ -255,7 +288,7 @@
 	}
 
 	DLOG( L << Logger::Debug << m_myname << " Search = basedn: " << dn + getArg( "basedn" ) << ", filter: " << filter << ", qtype: " << qtype.getName() << endl );
-	m_msgid = m_pldap->search( dn + getArg("basedn"), LDAP_SCOPE_BASE, filter, (const char**) attributes );
+	m_msgid = m_pldap->search( dn + getArg( "basedn" ), LDAP_SCOPE_BASE, filter, (const char**) attributes );
 }
 
 
@@ -304,7 +337,7 @@
 		{
 			vector<string>::iterator i;
 			for( i = m_result["associatedDomain"].begin(); i != m_result["associatedDomain"].end(); i++ ) {
-				if( i->substr( i->length() - m_axfrqlen, m_axfrqlen ) == m_qname ) {
+				if( i->size() >= m_axfrqlen && i->substr( i->size() - m_axfrqlen, m_axfrqlen ) == m_qname ) {
 					m_adomains.push_back( *i );
 				}
 			}
@@ -334,7 +367,7 @@
 		{
 			vector<string>::iterator i;
 			for( i = m_result["associatedDomain"].begin(); i != m_result["associatedDomain"].end(); i++ ) {
-				if( i->substr( i->length() - m_axfrqlen, m_axfrqlen ) == m_qname ) {
+				if( i->size() >= m_axfrqlen && i->substr( i->size() - m_axfrqlen, m_axfrqlen ) == m_qname ) {
 					m_adomains.push_back( *i );
 				}
 			}
@@ -428,7 +461,7 @@
 	}
 	catch( exception &e )
 	{
-		L << Logger::Error << m_myname << " Caught STL exception for attribute " << attrname << ": " << e.what() << endl;
+		L << Logger::Error << m_myname << " Caught STL exception for " << m_qname << ": " << e.what() << endl;
 		throw( DBException( "STL exception" ) );
 	}
 
@@ -454,7 +487,7 @@
 		declare( suffix, "basedn", "Search root in ldap tree (must be set)","" );
 		declare( suffix, "binddn", "User dn for non anonymous binds","" );
 		declare( suffix, "secret", "User password for non anonymous binds", "" );
-		declare( suffix, "method", "How to search entries (simple, strict or tree)", "list" );
+		declare( suffix, "method", "How to search entries (simple, strict or tree)", "simple" );
 		declare( suffix, "disable-ptrrecord", "Depricated, use ldap-method=strict instead", "no" );
 	}
 
diff -urNad trunk/modules/ldapbackend/ldapbackend.hh /tmp/dpep.52OPft/trunk/modules/ldapbackend/ldapbackend.hh
--- trunk/modules/ldapbackend/ldapbackend.hh	2005-04-09 23:02:03.539792168 +0200
+++ /tmp/dpep.52OPft/trunk/modules/ldapbackend/ldapbackend.hh	2005-04-10 17:43:04.483894072 +0200
@@ -74,10 +74,11 @@
 class LdapBackend : public DNSBackend
 {
 	bool m_getdn;
+	bool m_qlog;
 	int m_msgid;
-	int m_axfrqlen;
 	u_int32_t m_ttl;
 	u_int32_t m_default_ttl;
+	unsigned int m_axfrqlen;
 	string m_myname;
 	string m_qname;
 	QType m_qtype;
@@ -92,11 +93,11 @@
 	bool (LdapBackend::*m_prepare_fcnt)();
 
 	bool list_simple( const string& target, int domain_id );
-	bool list_tree( const string& target, int domain_id );
+	bool list_strict( const string& target, int domain_id );
 
-	void lookup_simple( const QType& qtype, const string& qdomain, DNSPacket* p = 0, int zoneid = -1 );
-	void lookup_strict( const QType& qtype, const string& qdomain, DNSPacket* p = 0, int zoneid = -1 );
-	void lookup_tree( const QType& qtype, const string& qdomain, DNSPacket* p = 0, int zoneid = -1 );
+	void lookup_simple( const QType& qtype, const string& qdomain, DNSPacket* p, int zoneid );
+	void lookup_strict( const QType& qtype, const string& qdomain, DNSPacket* p, int zoneid );
+	void lookup_tree( const QType& qtype, const string& qdomain, DNSPacket* p, int zoneid );
 
 	bool prepare();
 	bool prepare_simple();
diff -urNad trunk/modules/ldapbackend/powerldap.cc /tmp/dpep.52OPft/trunk/modules/ldapbackend/powerldap.cc
--- trunk/modules/ldapbackend/powerldap.cc	2005-04-09 23:02:03.537792472 +0200
+++ /tmp/dpep.52OPft/trunk/modules/ldapbackend/powerldap.cc	2005-04-10 17:43:04.484893920 +0200
@@ -145,7 +145,7 @@
 	if( dn )
 	{
 		attr = ldap_get_dn( d_ld, object );
-		values.push_back( attr );
+		values.push_back( string( attr ) );
 		ldap_memfree( attr );
 		entry["dn"] = values;
 	}
